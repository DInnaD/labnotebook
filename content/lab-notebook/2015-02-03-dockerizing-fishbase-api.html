---
date: 2015-02-03T00:00:00Z
tags:
- docker
url: /2015/02/03/dockerizing-fishbase-api/
---



<div id="dockerized-mysql-background" class="section level3">
<h3>Dockerized MySQL background</h3>
<p>Figuring out using an external MySQL docker container for the in-development fishbase API.</p>
<pre class="bash"><code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql
docker run --rm -ti --link some-mysql:mysql ubuntu:latest bash</code></pre>
<p>Now that we’re inside the ubuntu container we can see linked environment:</p>
<pre class="bash"><code>env</code></pre>
<p>shows</p>
<pre><code>HOSTNAME=57fd2b08094a
MYSQL_ENV_MYSQL_ROOT_PASSWORD=mysecretpassword
TERM=xterm
MYSQL_PORT_3306_TCP_PORT=3306
MYSQL_PORT_3306_TCP=tcp://172.17.0.32:3306
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
MYSQL_ENV_MYSQL_VERSION=5.6.22
SHLVL=1
HOME=/root
MYSQL_NAME=/some-app/mysql
MYSQL_PORT_3306_TCP_PROTO=tcp
MYSQL_PORT_3306_TCP_ADDR=172.17.0.32
LESSOPEN=| /usr/bin/lesspipe %s
MYSQL_ENV_MYSQL_MAJOR=5.6
MYSQL_PORT=tcp://172.17.0.32:3306
LESSCLOSE=/usr/bin/lesspipe %s %s
_=/usr/bin/env</code></pre>
<p>Great. Now we need a mysql client to access the host:</p>
<pre class="bash"><code>apt-get update &amp;&amp; apt-get install -y mysql-client-core-5.6</code></pre>
<p>Note that we cannot simply do:</p>
<pre class="bash"><code>mysql --password=$MYSQL_ENV_MYSQL_ROOT_PASSWORD</code></pre>
<p>which gives the error:</p>
<pre><code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2)</code></pre>
<p>Instead, we must also specify the protocol and port of the server:</p>
<pre class="bash"><code>mysql --host=$MYSQL_PORT_3306_TCP_ADDR --protocol=$MYSQL_PORT_3306_TCP_PROTO --password=$MYSQL_ENV_MYSQL_ROOT_PASSWORD</code></pre>
<p><strong>EDIT</strong> It’s much better to use the hostname provided by the linked container in <code>/etc/hosts</code>. This automatically binds the name used in the link <code>mysql</code> to the linked container’s IP address, so we can simply do: <code>mysql =--host=mysql --password=$MYSQL_ENV_MYSQL_ROOT_PASSWORD</code> (protocol, like the port, is guessed implicitly from host). Unlike the env var solution, the <code>/etc/hosts</code> file is updated if the <code>mysql</code> container restarts.</p>
<p>and we’re good to go:</p>
<pre><code>Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.6.22 MySQL Community Server (GPL)

Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&gt; </code></pre>
</div>
<div id="applying-this-in-fishbaseapi" class="section level3">
<h3>Applying this in fishbaseapi</h3>
<p>Scott has put together a nice start to the fishbase API built on Ruby’s <code>sinatra</code> gem.</p>
<p>First step is to import the SQL database archive.</p>
<p>For our database to persist even if our container is destroyed, we link it to a local volume. So we start a <code>mysql</code> container with a local volume link, e.g. to <code>/opt/fishbase/data</code> on the server:</p>
<pre class="bash"><code>sudo mkdir -p /opt/fishbase/data
docker run --name mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d -v /opt/fishbase/data:/var/lib/mysql mysql</code></pre>
<p>We now need to import the data from the <code>fbapp.sql</code> file as a one-off event. We’ll use a temporary <code>mysql</code> container to do this, linked to the persistent image we just launched. For this container, we’ll start a bash container that is linked to the <code>fbapp.sql</code> file directly (note that docker volume linking works for files too):</p>
<pre class="bash"><code>docker run --rm -ti --link mysql:mysql -v /path/to/fbapp.sql:/data/fbapp.sql -w /data mysql bash</code></pre>
<p>This drops us into a bash session on the container where we can launch a linked <code>mysql</code> session and import our tables:</p>
<pre class="bash"><code>mysql --host=$MYSQL_PORT_3306_TCP_ADDR --protocol=$MYSQL_PORT_3306_TCP_PROTO --password=$MYSQL_ENV_MYSQL_ROOT_PASSWORD fbapp &lt; fbapp.sql</code></pre>
<p>Note: if this gives us an error about being unable to write the table, we may need to adjust the permissions of the linked file appropriately.</p>
<pre><code>docker exec -ti mysql bash
chown -R mysql:mysql /var/lib/mysql</code></pre>
<p>From here, the database is set up and ready to be linked to our app.</p>
</div>
<div id="dockerizing-the-sinatra-app" class="section level3">
<h3>Dockerizing the Sinatra app</h3>
<p>This is straight-forward, noting only that we need to again use the environmental variables shown for the <code>mysql</code> credentials inside our ruby script:</p>
<pre class="ruby"><code>  client = Mysql2::Client.new(:host =&gt; ENV[&#39;MYSQL_PORT_3306_TCP_ADDR&#39;], 
                             :port =&gt; ENV[&#39;MYSQL_PORT_3306_TCP_PORT&#39;], 
                             :password =&gt; ENV[&#39;MYSQL_ENV_MYSQL_ROOT_PASSWORD&#39;],
                             :username =&gt; &quot;root&quot;, 
                             :database =&gt; &quot;fbapp&quot;)</code></pre>
<p>and that we need to execute our ruby app with host <code>0.0.0.0</code> instead of the default <code>localhost</code> so that the port will be accessible outside the docker container, like so:</p>
<pre class="bash"><code>ruby api.rb -o 0.0.0.0</code></pre>
<p>We could get away with just a 2-line Dockerfile using the <code>onbuild</code> flavor of the official Ruby containers, which has rather clever triggers for installing dependencies listed in the Gemfile when the image is built, see <a href="https://registry.hub.docker.com/_/ruby/">DockerHub/ruby</a>.</p>
<p>Since one still needs to build a new Docker image either way, I’ve opted for a slightly more explicit (and smaller) <a href="https://github.com/ropensci/fishbaseapi/blob/master/Dockerfile">Dockerfile</a> based on Debian instead. This installs the ruby dependencies (including gems and associated libraries, which would all have been automated by the Ruby Dockerfile), and sets up a default run command to launch the app running the sinatra API.</p>
<p>Just run this container linked to the database and we’re good to go:</p>
<pre class="bash"><code>docker run -d -p 4567:4567 --link mysql:mysql ropensci/rfishbase</code></pre>
</div>
